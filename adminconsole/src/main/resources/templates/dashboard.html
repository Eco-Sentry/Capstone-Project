



















<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon">

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="css/default.css">
    <title>Dashboard</title>

    <style>
        #searchList {
          height: 120px;
          overflow-y: auto;
          border: 1px solid #ccc;
          width: 260px;
          padding: 5px;
          background-color: white;
          box-shadow: inset 0 10px 10px -10px rgba(0, 0, 0, 0.5), /* Top shadow */
                        inset 0 -10px 10px -10px rgba(0, 0, 0, 0.5); /* Bottom shadow */
        }
        .item {
          margin: 5px;
        }


        input[type="datetime-local"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            box-sizing: border-box;
            transition: border-color 0.3s ease;
        }
        input[type="datetime-local"]:focus {
            border-color: #66afe9;
            outline: none;
        }

      </style>

</head>
<body>
    <div class="navbar">
        <div class="logo">
            <img src="images/Logo.png" alt="Logo" class="logo-image">         
        </div>
        
        <nav class="nav-links">
            <a th:href="@{home}">Home</a>
            <a th:href="@{about}">About</a>
            <a th:href="@{guide}">Guide</a>
            <a th:href="@{profile}">Profile</a>
            <a th:href="@{dashboard}">Dashboard</a>
            <a th:href="@{mySentries}">My Sentries</a>
        </nav>
    </div>
    <button class="sidebar-toggle" onclick="toggleSidebar()">â‡’</button>
    <div class="sidebar" id="sidebar">
        <h2>Dashboard</h2><br>
        <p style="color: red;">Warning for the TRADESHOW. Our systems are running on cheap hardware for the time being to keep costs down. Please be aware that our systems may be being hit harder than expected right now. Be patient with our graphing system, you are in the queue!</p><br>
        <h4>Select Graph</h4>
        <div>
            <label>
                <input type="radio" name="graphType" value="multi-sensor" checked>
                Multi-Sensor Graph
            </label><br>
            <label>
                <input type="radio" name="graphType" value="correlation">
                Correlation Plot
            </label><br>
            <label>
                <input type="radio" name="graphType" value="heatmap">
                Heatmap
            </label><br>
            <label>
                <input type="radio" name="graphType" value="scatter">
                Scatter Plot
            </label><br><br>
        </div>
        



        <div>
            <h4>Start DatTime</h4>
            <input type="datetime-local" id="startTimeInput" value="2024-05-06T04:01">
            <h4>End DatTime</h4>
            <input type="datetime-local" id="endTimeInput" value="2024-05-06T06:40">
            <h4>Range (km)</h4>
            <input style="width: 100%;" type="number" id="rangeInput" value="25">
            <!-- <button onclick="refreshIframe()">Refresh</button> -->
        </div>

        <br><h4>Sensor Type</h4>
        <input style="width: 100%;" type="text" id="searchInput" onkeyup="filterList()" placeholder="Search for sensor types...">
        <div id="searchList"></div>
        <br><button class="ran-button" onclick="refreshIframe()">Refresh Graph</button>
    </div>
    <div class="content">
        <div class="search-area">
            <input type="text" class="search-input" id="address" placeholder="Search..." oninput="showSuggestions()" >
            <button class="ran-button" onclick="geocode()">Search</button>
            

            

        </div>
        <div id="suggestions"></div>
        <p id="result"></p>

        
        <div class="main-div">
            <iframe id="dataFrame" style="width: 100%; height: 80vh; border: none;"></iframe>
        </div>
    </div>
    <script>

        let debounceTimeout;
        var fullLong = 150.8949804;
        var fullLat = -34.3923891;
        function debounce(func, delay) {
            return function(...args) {
                clearTimeout(debounceTimeout);
                debounceTimeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        const showSuggestions = debounce(function() {
            const address = document.getElementById('address').value;
            if (address.length < 3) {
                document.getElementById('suggestions').innerHTML = '';
                return;
            }

            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&addressdetails=1&limit=3`;


            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    const suggestions = document.getElementById('suggestions');
                    suggestions.innerHTML = '';
                    if (data.length > 0) {
                        data.forEach(item => {
                            const suggestion = document.createElement('div');
                            suggestion.classList.add('suggestion');
                            suggestion.innerText = item.display_name;
                            suggestion.onclick = () => {
                                document.getElementById('address').value = item.display_name;
                                suggestions.innerHTML = '';
                            };
                            suggestions.appendChild(suggestion);
                        });
                    } else {
                        suggestions.innerHTML = '<div class="suggestion">No results found</div>';
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
        }, 1000);

        function geocode() {
            const address = document.getElementById('address').value;
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`;

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.length > 0) {
                        const result = data[0];
                        fullLat = result.lat;
                        fullLong = result.lon;
                        refreshIframe();
                        document.getElementById('result').innerText = `Latitude: ${result.lat}, Longitude: ${result.lon}`;
                    } else {
                        document.getElementById('result').innerText = 'No results found';
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    document.getElementById('result').innerText = 'An error occurred';
                });
        }

        async function fetchSensorTypes() {
            try {
                const response = await fetch('https://www.eco-sentry.com/api/get-sensor-types');
                const data = await response.json();
                // Sort data by popularity in descending order
                data.sort((a, b) => b.popularity - a.popularity);
                populateList(data);
            } catch (error) {
                console.error('Error fetching sensor types:', error);
            }
        }

        // Function to populate the list with items
        function populateList(sensorTypes) {
            const listDiv = document.getElementById('searchList');
            sensorTypes.forEach((sensor, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'item';
                itemDiv.style.display = ''; // Make sure all items are visible initially
                // Modified line to ensure the first item is always checked
                itemDiv.innerHTML = `<input type="checkbox" id="${sensor.id}" ${index === 0 ? 'checked' : ''}> ${sensor.sensorType}`;
                itemDiv.dataset.popularity = sensor.popularity; // Store popularity as a data attribute
                listDiv.appendChild(itemDiv);
            });
            refreshIframe();
        }
        function getCheckedSensorIds() {
            const listDiv = document.getElementById('searchList');
            const checkboxes = listDiv.querySelectorAll('input[type="checkbox"]');
            const checkedIds = [];

            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                checkedIds.push(checkbox.id);
                }
            });

            return checkedIds;
        }
        
        // Function to filter the list based on search input
        function filterList() {
          var input, filter, div, items, txtValue, itemPopularity, popularityFilter;
          input = document.getElementById('searchInput');
          filter = input.value.toUpperCase();
          div = document.getElementById('searchList');
          items = div.getElementsByClassName('item');
          for (let i = 0; i < items.length; i++) {
            txtValue = items[i].textContent || items[i].innerText;
            itemPopularity = items[i].dataset.popularity;
            popularityFilter = filter.match(/\d+/) ? filter.match(/\d+/)[0] : null; // Extract numbers from filter input
            if (txtValue.toUpperCase().indexOf(filter.replace(/\d+/g, '').trim()) > -1 && 
                (popularityFilter === null || itemPopularity === popularityFilter)) {
              items[i].style.display = "";
            } else {
              items[i].style.display = "none";
            }
          }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const status = document.getElementById('status');
            const locationElement = document.getElementById('location');

            // Check if Geolocation is supported
            if ('geolocation' in navigator) {
                navigator.geolocation.getCurrentPosition(success, error);
            } else {
                status.textContent = 'Geolocation is not supported by your browser';
            }

            // Success callback
            function success(position) {
                fullLat = position.coords.latitude;
                fullLong = position.coords.longitude;
                status.textContent = 'Location fetched successfully!';
                locationElement.textContent = `Latitude: ${latitude}, Longitude: ${longitude}`;
            }

            // Error callback
            function error() {
                status.textContent = 'Unable to retrieve your location';
            }
        });

        
        // Initial fetch of sensor types when the document loads
        document.addEventListener('DOMContentLoaded', fetchSensorTypes);
    </script>
    <script>
        function setupDateTimeInputs() {
            const now = new Date();
            const oneDayAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
        
            // Formatting to datetime-local input format YYYY-MM-DDTHH:mm
            const formatDateTimeLocal = (date) => {
                const off = date.getTimezoneOffset();
                const adjustedDate = new Date(date.getTime() - off * 60 * 1000);
                return adjustedDate.toISOString().slice(0, 16);
            };
        
            document.getElementById('endTimeInput').value = formatDateTimeLocal(now);
            document.getElementById('startTimeInput').value = formatDateTimeLocal(oneDayAgo);
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            setupDateTimeInputs(); // Set the initial date and time for inputs
            refreshIframe(); // Load the iframe content based on the default times
        });
    </script>
        
    <script>
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            if (sidebar.style.transform === 'translateX(0px)') {
                sidebar.style.transform = 'translateX(-100%)'; // Hide the sidebar
            } else {
                sidebar.style.transform = 'translateX(0px)'; // Show the sidebar
            }
        }
        // Add event listener to handle window resizing
        window.addEventListener('resize', function() {
            const sidebar = document.getElementById('sidebar');
            if (window.innerWidth >= 768) {
                // Ensure sidebar is open on larger screens
                sidebar.style.transform = 'translateX(0px)';
            } else if (window.innerWidth < 768 && sidebar.style.transform === 'translateX(0px)') {
                // Keep current state if the sidebar is already open
                sidebar.style.transform = 'translateX(-100%)';
                return;
            } else {
                // Ensure sidebar is closed on smaller screens when not specifically toggled
                sidebar.style.transform = 'translateX(-100%)';
            }
        });

        function refreshIframe() {
            const iframe = document.getElementById('dataFrame');
            if (iframe.contentWindow) {
                loadIframeContent();
            } else {
                iframe.onload = loadIframeContent; // Wait for the iframe to load before loading content
            }
        }

        function formatDateTimeForAPI(datetimeValue) {
            // Adding seconds and 'Z' to make it ISO 8601 complete UTC time
            return new Date(datetimeValue).toISOString();
        }

        // function loadIframeContent() {
        //     const iframe = document.getElementById('dataFrame');
        //     const startTime = formatDateTimeForAPI(document.getElementById('startTimeInput').value);
        //     const endTime = formatDateTimeForAPI(document.getElementById('endTimeInput').value);
        //     const range = document.getElementById('rangeInput').value;

        //     const selectedGraphType = document.querySelector('input[name="graphType"]:checked').value;
        //     let url = 'https://www.eco-sentry.com/generate-multi-sensor-graph';
        //     let bodyJSON = JSON.stringify({
        //             startTime,
        //             endTime,
        //             longitude: fullLong,
        //             latitude: fullLat,
        //             range,
        //             sensorTypes: getCheckedSensorIds()
        //         })
        //     if (selectedGraphType === 'multi-sensor') {
        //         url = 'https://www.eco-sentry.com/generate-multi-sensor-graph';
        //         bodyJSON = JSON.stringify({
        //             startTime,
        //             endTime,
        //             longitude: fullLong,
        //             latitude: fullLat,
        //             range,
        //             sensorTypes: getCheckedSensorIds()
        //         });
        //     } else if (selectedGraphType === 'correlation') {
        //         url = 'https://www.eco-sentry.com/generate-correlation-plot';
        //         bodyJSON = JSON.stringify({
        //             startTime,
        //             endTime,
        //             longitude: fullLong,
        //             latitude: fullLat,
        //             range,
        //             sensorTypes: getCheckedSensorIds()
        //         });
        //     }
        //     else if (selectedGraphType === 'heatmap') {
        //         url = 'https://www.eco-sentry.com/generate-heatmap';
        //         bodyJSON = JSON.stringify({
        //             startTime,
        //             endTime,
        //             longitude: fullLong,
        //             latitude: fullLat,
        //             range,
        //             sensorType: getCheckedSensorIds()
        //         });

                
        //     }
        //     else if (selectedGraphType === 'scatter') {
        //         url = 'https://www.eco-sentry.com/generate-scatter-plot';
        //         bodyJSON = JSON.stringify({
        //             startTime,
        //             endTime,
        //             longitude: fullLong,
        //             latitude: fullLat,
        //             range,
        //             sensorA: getCheckedSensorIds()[0],
        //             sensorB: getCheckedSensorIds()[1]
        //         });
        //     }


        //     fetch(url, {
        //         method: 'POST',
        //         headers: {
        //             'Content-Type': 'application/json'
        //         },
        //         body: bodyJSON
        //     }).then(response => response.text())
        //     .then(html => {
        //         const doc = iframe.contentWindow.document;
        //         doc.open();
        //         doc.write(html);
        //         doc.close();
        //     }).catch(error => console.error('Error loading the iframe content:', error));
        // }
        function loadIframeContent() {
            const iframe = document.getElementById('dataFrame');
            const startTime = formatDateTimeForAPI(document.getElementById('startTimeInput').value);
            const endTime = formatDateTimeForAPI(document.getElementById('endTimeInput').value);
            const range = document.getElementById('rangeInput').value;

            const selectedGraphType = document.querySelector('input[name="graphType"]:checked').value;
            let url = '';
            let bodyJSON = JSON.stringify({
                startTime,
                endTime,
                longitude: fullLong,
                latitude: fullLat,
                range,
                sensorTypes: getCheckedSensorIds()
            });

            if (selectedGraphType === 'multi-sensor') {
                url = 'https://www.eco-sentry.com/generate-multi-sensor-graph';
            } else if (selectedGraphType === 'correlation') {
                url = 'https://www.eco-sentry.com/generate-correlation-plot';
            } else if (selectedGraphType === 'heatmap') {
                url = 'https://www.eco-sentry.com/generate-heatmap';
                bodyJSON = JSON.stringify({
                    startTime,
                    endTime,
                    longitude: fullLong,
                    latitude: fullLat,
                    range,
                    sensorType: getCheckedSensorIds()
                });
            } else if (selectedGraphType === 'scatter') {
                url = 'https://www.eco-sentry.com/generate-scatter-plot';
                bodyJSON = JSON.stringify({
                    startTime,
                    endTime,
                    longitude: fullLong,
                    latitude: fullLat,
                    range,
                    sensorA: getCheckedSensorIds()[0],
                    sensorB: getCheckedSensorIds()[1]
                });
            }

            fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: bodyJSON
            }).then(response => {
                if (selectedGraphType === 'heatmap') {
                    return response.json();
                } else {
                    return response.text();
                }
            }).then(data => {
                if (selectedGraphType === 'heatmap') {
                    const taskId = data.task_id;
                    checkTaskStatus(taskId, iframe);
                } else {
                    const doc = iframe.contentWindow.document;
                    doc.open();
                    doc.write(data);
                    doc.close();
                }
            }).catch(error => console.error('Error loading the iframe content:', error));
        }

        function checkTaskStatus(taskId, iframe) {
            const statusUrl = `https://www.eco-sentry.com/task-status/${taskId}`;
            fetch(statusUrl)
                .then(response => response.json())
                .then(data => {
                    if (data.state === 'SUCCESS') {
                        const doc = iframe.contentWindow.document;
                        doc.open();
                        doc.write(data.result);
                        doc.close();
                    } else if (data.state === 'PENDING' || data.state === 'PROGRESS') {
                        setTimeout(() => checkTaskStatus(taskId, iframe), 2000);
                    } else {
                        console.error('Task failed or encountered an error:', data);
                    }
                })
                .catch(error => console.error('Error checking task status:', error));
        }












































        document.addEventListener('DOMContentLoaded', function () {
            const navbar = document.querySelector('.navbar');

            navbar.addEventListener('click', function(event) {
                if (window.innerWidth < 768) {
                    navbar.classList.toggle('active');
                    if (navbar.classList.contains('active')) {
                        navbar.style.height = '100vh'; // Full height
                    } else {
                        navbar.style.height = '60px'; // Default height
                    }
                }
            });

            window.addEventListener('resize', function() {
                if (window.innerWidth >= 768) {
                    navbar.classList.remove('active');
                    navbar.style.height = '60px'; // Ensure default height
                }
            });

            const sidebar = document.getElementById('sidebar');
            if (window.innerWidth >= 768) {
                // Ensure sidebar is open on larger screens
                sidebar.style.transform = 'translateX(0px)';
            } else if (window.innerWidth < 768 && sidebar.style.transform === 'translateX(0px)') {
                // Keep current state if the sidebar is already open
                return;
            } else {
                // Ensure sidebar is closed on smaller screens when not specifically toggled
                sidebar.style.transform = 'translateX(-100%)';
            }
        });

        refreshIframe(); // Initial load when everything is set up
    </script>
</body>
</html>
